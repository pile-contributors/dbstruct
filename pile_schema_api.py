#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Nov 22 01:54:27 2015 by generateDS.py version 2.17a.
#
# Command line options:
#   ('--cleanup-name-list', "[(':', '__'), ('-', '___'), ('\\\\.', '____'), ('^int$', 'integer')]")
#   ('--member-specs', 'dict')
#   ('--no-questions', '')
#   ('-f', '')
#   ('-o', 'H:\\prog\\agreece\\cpp-app\\lib_agreece\\support\\dbstruct\\pile_schema_api.py')
#
# Command line arguments:
#   H:\prog\agreece\cpp-app\lib_agreece\support\dbstruct\PileSchema.xsd
#
# Command line:
#   C:\pf\Python27\Scripts\generateDS.py --cleanup-name-list="[(':', '__'), ('-', '___'), ('\\.', '____'), ('^int$', 'integer')]" --member-specs="dict" --no-questions -f -o "H:\prog\agreece\cpp-app\lib_agreece\support\dbstruct\pile_schema_api.py" H:\prog\agreece\cpp-app\lib_agreece\support\dbstruct\PileSchema.xsd
#
# Current working directory (os.getcwd()):
#   cpp-build-debug-64
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class parameterlessType(GeneratedsSuper):
    member_data_items_ = {
    }
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if parameterlessType.subclass:
            return parameterlessType.subclass(*args_, **kwargs_)
        else:
            return parameterlessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='parameterlessType', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parameterlessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='parameterlessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='parameterlessType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='parameterlessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class parameterlessType


class identity(GeneratedsSuper):
    """The column containing this element is the identity column.TODO: What
    is this?The increment step to use.TODO: What is this?"""
    member_data_items_ = {
        'seed': MemberSpec_('seed', 'xs:integer', 0),
        'increment': MemberSpec_('increment', 'xs:integer', 0),
        'notForReplication': MemberSpec_('notForReplication', 'xs:boolean', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, seed=None, increment=None, notForReplication=None):
        self.original_tagname_ = None
        self.seed = _cast(int, seed)
        self.increment = _cast(int, increment)
        self.notForReplication = _cast(bool, notForReplication)
    def factory(*args_, **kwargs_):
        if identity.subclass:
            return identity.subclass(*args_, **kwargs_)
        else:
            return identity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_seed(self): return self.seed
    def set_seed(self, seed): self.seed = seed
    def get_increment(self): return self.increment
    def set_increment(self, increment): self.increment = increment
    def get_notForReplication(self): return self.notForReplication
    def set_notForReplication(self, notForReplication): self.notForReplication = notForReplication
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='identity', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='identity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='identity'):
        if self.seed is not None and 'seed' not in already_processed:
            already_processed.add('seed')
            outfile.write(' seed="%s"' % self.gds_format_integer(self.seed, input_name='seed'))
        if self.increment is not None and 'increment' not in already_processed:
            already_processed.add('increment')
            outfile.write(' increment="%s"' % self.gds_format_integer(self.increment, input_name='increment'))
        if self.notForReplication is not None and 'notForReplication' not in already_processed:
            already_processed.add('notForReplication')
            outfile.write(' notForReplication="%s"' % self.gds_format_boolean(self.notForReplication, input_name='notForReplication'))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='identity', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('seed', node)
        if value is not None and 'seed' not in already_processed:
            already_processed.add('seed')
            try:
                self.seed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('increment', node)
        if value is not None and 'increment' not in already_processed:
            already_processed.add('increment')
            try:
                self.increment = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('notForReplication', node)
        if value is not None and 'notForReplication' not in already_processed:
            already_processed.add('notForReplication')
            if value in ('true', '1'):
                self.notForReplication = True
            elif value in ('false', '0'):
                self.notForReplication = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identity


class bit(GeneratedsSuper):
    """Boolean column data type.Default value for the column.The type to
    use to represent this column in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:boolean', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='bool'):
        self.original_tagname_ = None
        self.default = _cast(bool, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if bit.subclass:
            return bit.subclass(*args_, **kwargs_)
        else:
            return bit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='bit', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='bit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='bit'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_boolean(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "bool" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='bit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bit


class integer(GeneratedsSuper):
    """Common integer (int) column data type.Default value for the
    column.The type to use to represent this column in a Qt source
    file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:int', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'identity': MemberSpec_('identity', 'identity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='int', identity=None, valueOf_=None):
        self.original_tagname_ = None
        self.default = _cast(int, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
        self.identity = identity
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if integer.subclass:
            return integer.subclass(*args_, **kwargs_)
        else:
            return integer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identity(self): return self.identity
    def set_identity(self, identity): self.identity = identity
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (
            self.identity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='int', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='int')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='int', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='int'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_integer(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "int" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='int', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identity is not None:
            self.identity.export(outfile, level, namespace_, name_='identity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identity':
            obj_ = identity.factory()
            obj_.build(child_)
            self.identity = obj_
            obj_.original_tagname_ = 'identity'
# end class integer


class bigint(GeneratedsSuper):
    """Large integer (long) column data type.Default value for the
    column.The type to use to represent this column in a Qt source
    file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:long', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'identity': MemberSpec_('identity', 'identity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='long', identity=None):
        self.original_tagname_ = None
        self.default = _cast(int, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
        self.identity = identity
    def factory(*args_, **kwargs_):
        if bigint.subclass:
            return bigint.subclass(*args_, **kwargs_)
        else:
            return bigint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identity(self): return self.identity
    def set_identity(self, identity): self.identity = identity
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (
            self.identity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='bigint', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bigint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='bigint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='bigint'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_integer(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "long" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='bigint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identity is not None:
            self.identity.export(outfile, level, namespace_, name_='identity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identity':
            obj_ = identity.factory()
            obj_.build(child_)
            self.identity = obj_
            obj_.original_tagname_ = 'identity'
# end class bigint


class smallint(GeneratedsSuper):
    """Small integer (short) column data type.Default value for the
    column.The type to use to represent this column in a Qt source
    file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:short', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'identity': MemberSpec_('identity', 'identity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='short', identity=None):
        self.original_tagname_ = None
        self.default = _cast(int, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
        self.identity = identity
    def factory(*args_, **kwargs_):
        if smallint.subclass:
            return smallint.subclass(*args_, **kwargs_)
        else:
            return smallint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identity(self): return self.identity
    def set_identity(self, identity): self.identity = identity
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (
            self.identity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='smallint', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smallint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='smallint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='smallint'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_integer(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "short" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='smallint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identity is not None:
            self.identity.export(outfile, level, namespace_, name_='identity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identity':
            obj_ = identity.factory()
            obj_.build(child_)
            self.identity = obj_
            obj_.original_tagname_ = 'identity'
# end class smallint


class tinyint(GeneratedsSuper):
    """Tiny integer (byte) column data type.Default value for the
    column.The type to use to represent this column in a Qt source
    file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:byte', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'identity': MemberSpec_('identity', 'identity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='char', identity=None):
        self.original_tagname_ = None
        self.default = _cast(int, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
        self.identity = identity
    def factory(*args_, **kwargs_):
        if tinyint.subclass:
            return tinyint.subclass(*args_, **kwargs_)
        else:
            return tinyint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identity(self): return self.identity
    def set_identity(self, identity): self.identity = identity
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (
            self.identity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='tinyint', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tinyint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='tinyint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='tinyint'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_integer(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "char" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='tinyint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identity is not None:
            self.identity.export(outfile, level, namespace_, name_='identity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identity':
            obj_ = identity.factory()
            obj_.build(child_)
            self.identity = obj_
            obj_.original_tagname_ = 'identity'
# end class tinyint


class float_(GeneratedsSuper):
    """Real number (float) column data type.The type to use to represent
    this column in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:decimal', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'mantissaBits': MemberSpec_('mantissaBits', 'mantissaBits', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, qtype='float', mantissaBits=None, defaultExpression=None, valueOf_=None):
        self.original_tagname_ = None
        self.default = _cast(float, default)
        self.qtype = _cast(None, qtype)
        self.mantissaBits = _cast(None, mantissaBits)
        self.defaultExpression = _cast(None, defaultExpression)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if float_.subclass:
            return float_.subclass(*args_, **kwargs_)
        else:
            return float_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def get_mantissaBits(self): return self.mantissaBits
    def set_mantissaBits(self, mantissaBits): self.mantissaBits = mantissaBits
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def validate_mantissaBits(self, value):
        # Validate type mantissaBits, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on mantissaBits' % {"value" : value} )
            if value > 53:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on mantissaBits' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='float', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='float')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='float', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='float'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_float(self.default, input_name='default'))
        if self.qtype != "float" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
        if self.mantissaBits is not None and 'mantissaBits' not in already_processed:
            already_processed.add('mantissaBits')
            outfile.write(' mantissaBits=%s' % (quote_attrib(self.mantissaBits), ))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='float', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
        value = find_attr_value_('mantissaBits', node)
        if value is not None and 'mantissaBits' not in already_processed:
            already_processed.add('mantissaBits')
            try:
                self.mantissaBits = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_mantissaBits(self.mantissaBits)    # validate type mantissaBits
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class float_


class real(GeneratedsSuper):
    """Real number (double) column data type.Default value for the
    column.The type to use to represent this column in a Qt source
    file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:decimal', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='double'):
        self.original_tagname_ = None
        self.default = _cast(float, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if real.subclass:
            return real.subclass(*args_, **kwargs_)
        else:
            return real(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='real', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='real')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='real', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='real'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_float(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "double" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='real', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class real


class decimal(GeneratedsSuper):
    """Real number (float) column data type with precision and scale.Number
    of significant digits after decimal dot.TODO: What is
    this?Default value for this column.The type to use to represent
    this column in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:decimal', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'scale': MemberSpec_('scale', 'xs:integer', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'precision': MemberSpec_('precision', 'xs:integer', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, scale=None, qtype='double', precision=None, valueOf_=None):
        self.original_tagname_ = None
        self.default = _cast(float, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.scale = _cast(int, scale)
        self.qtype = _cast(None, qtype)
        self.precision = _cast(int, precision)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if decimal.subclass:
            return decimal.subclass(*args_, **kwargs_)
        else:
            return decimal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_scale(self): return self.scale
    def set_scale(self, scale): self.scale = scale
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='decimal', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decimal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='decimal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='decimal'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_float(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale="%s"' % self.gds_format_integer(self.scale, input_name='scale'))
        if self.qtype != "double" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision="%s"' % self.gds_format_integer(self.precision, input_name='precision'))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='decimal', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            try:
                self.scale = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            try:
                self.precision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class decimal


class decimalScale0(GeneratedsSuper):
    """Real number (float) column data type without a scale TODO: explain
    scale.Number of significant digits after decimal dot.Default
    value for this column.The type to use to represent this column
    in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:decimal', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
        'precision': MemberSpec_('precision', 'xs:integer', 0),
        'identity': MemberSpec_('identity', 'identity', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='double', precision=None, identity=None):
        self.original_tagname_ = None
        self.default = _cast(float, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
        self.precision = _cast(int, precision)
        self.identity = identity
    def factory(*args_, **kwargs_):
        if decimalScale0.subclass:
            return decimalScale0.subclass(*args_, **kwargs_)
        else:
            return decimalScale0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identity(self): return self.identity
    def set_identity(self, identity): self.identity = identity
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def hasContent_(self):
        if (
            self.identity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='decimalScale0', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decimalScale0')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='decimalScale0', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='decimalScale0'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_float(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "double" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision="%s"' % self.gds_format_integer(self.precision, input_name='precision'))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='decimalScale0', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identity is not None:
            self.identity.export(outfile, level, namespace_, name_='identity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            try:
                self.precision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identity':
            obj_ = identity.factory()
            obj_.build(child_)
            self.identity = obj_
            obj_.original_tagname_ = 'identity'
# end class decimalScale0


class money(GeneratedsSuper):
    """Default value for the column."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'moneydefault', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None):
        self.original_tagname_ = None
        self.default = _cast(None, default)
        self.defaultExpression = _cast(None, defaultExpression)
    def factory(*args_, **kwargs_):
        if money.subclass:
            return money.subclass(*args_, **kwargs_)
        else:
            return money(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def validate_moneydefault(self, value):
        # Validate type moneydefault, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < -922337203685477.5808:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on moneydefault' % {"value" : value} )
            if value > 922337203685477.5807:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on moneydefault' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on moneydefault' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='money', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='money')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='money', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='money'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (quote_attrib(self.default), ))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='money', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
            self.validate_moneydefault(self.default)    # validate type moneydefault
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class money


class smallmoney(GeneratedsSuper):
    """Default value for the column."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'smallmoneyDefault', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None):
        self.original_tagname_ = None
        self.default = _cast(None, default)
        self.defaultExpression = _cast(None, defaultExpression)
    def factory(*args_, **kwargs_):
        if smallmoney.subclass:
            return smallmoney.subclass(*args_, **kwargs_)
        else:
            return smallmoney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def validate_smallmoneyDefault(self, value):
        # Validate type smallmoneyDefault, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < -214748.3648:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on smallmoneyDefault' % {"value" : value} )
            if value > 214748.3647:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on smallmoneyDefault' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on smallmoneyDefault' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='smallmoney', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smallmoney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='smallmoney', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='smallmoney'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (quote_attrib(self.default), ))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='smallmoney', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
            self.validate_smallmoneyDefault(self.default)    # validate type smallmoneyDefault
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smallmoney


class parameterlessStringType(GeneratedsSuper):
    """String column data type.The type to use to represent this column in
    a Qt source file."""
    member_data_items_ = {
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'default': MemberSpec_('default', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, defaultExpression=None, default=None, qtype='QString'):
        self.original_tagname_ = None
        self.defaultExpression = _cast(None, defaultExpression)
        self.default = _cast(None, default)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if parameterlessStringType.subclass:
            return parameterlessStringType.subclass(*args_, **kwargs_)
        else:
            return parameterlessStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='parameterlessStringType', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parameterlessStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='parameterlessStringType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='parameterlessStringType'):
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.qtype != "QString" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='parameterlessStringType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            self.default = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class parameterlessStringType


class uniqueidentifier(GeneratedsSuper):
    """A unique identifier (GUID).The type to use to represent this column
    in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'GUID', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='QString'):
        self.original_tagname_ = None
        self.default = _cast(None, default)
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if uniqueidentifier.subclass:
            return uniqueidentifier.subclass(*args_, **kwargs_)
        else:
            return uniqueidentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def validate_GUID(self, value):
        # Validate type GUID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_GUID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_GUID_patterns_, ))
    validate_GUID_patterns_ = [['^\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='uniqueidentifier', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uniqueidentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='uniqueidentifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='uniqueidentifier'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (quote_attrib(self.default), ))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "QString" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='uniqueidentifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            self.default = value
            self.validate_GUID(self.default)    # validate type GUID
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class uniqueidentifier


class variablePrecisionTime(GeneratedsSuper):
    """Date and time column data type."""
    member_data_items_ = {
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'default': MemberSpec_('default', 'xs:string', 0),
        'fractionalSecondsPrecision': MemberSpec_('fractionalSecondsPrecision', 'fractionalSecondsPrecision', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, defaultExpression=None, default=None, fractionalSecondsPrecision=None):
        self.original_tagname_ = None
        self.defaultExpression = _cast(None, defaultExpression)
        self.default = _cast(None, default)
        self.fractionalSecondsPrecision = _cast(None, fractionalSecondsPrecision)
    def factory(*args_, **kwargs_):
        if variablePrecisionTime.subclass:
            return variablePrecisionTime.subclass(*args_, **kwargs_)
        else:
            return variablePrecisionTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_fractionalSecondsPrecision(self): return self.fractionalSecondsPrecision
    def set_fractionalSecondsPrecision(self, fractionalSecondsPrecision): self.fractionalSecondsPrecision = fractionalSecondsPrecision
    def validate_fractionalSecondsPrecision(self, value):
        # Validate type fractionalSecondsPrecision, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on fractionalSecondsPrecision' % {"value" : value} )
            if value > 7:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on fractionalSecondsPrecision' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='variablePrecisionTime', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variablePrecisionTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='variablePrecisionTime', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='variablePrecisionTime'):
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.fractionalSecondsPrecision is not None and 'fractionalSecondsPrecision' not in already_processed:
            already_processed.add('fractionalSecondsPrecision')
            outfile.write(' fractionalSecondsPrecision=%s' % (quote_attrib(self.fractionalSecondsPrecision), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='variablePrecisionTime', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            self.default = value
        value = find_attr_value_('fractionalSecondsPrecision', node)
        if value is not None and 'fractionalSecondsPrecision' not in already_processed:
            already_processed.add('fractionalSecondsPrecision')
            try:
                self.fractionalSecondsPrecision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_fractionalSecondsPrecision(self.fractionalSecondsPrecision)    # validate type fractionalSecondsPrecision
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class variablePrecisionTime


class dateType(GeneratedsSuper):
    """A date (without time component).Default value for the column.The
    type to use to represent this column in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:date', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='QDate'):
        self.original_tagname_ = None
        if isinstance(default, basestring):
            initvalue_ = datetime_.datetime.strptime(default, '%Y-%m-%d').date()
        else:
            initvalue_ = default
        self.default = initvalue_
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if dateType.subclass:
            return dateType.subclass(*args_, **kwargs_)
        else:
            return dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='dateType', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='dateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='dateType'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_date(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "QDate" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='dateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (default): %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateType


class timeType(GeneratedsSuper):
    """A time (without date component).Default value for the column.The
    type to use to represent this column in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:time', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='QTime'):
        self.original_tagname_ = None
        if isinstance(default, basestring):
            initvalue_ = datetime_.datetime.strptime(default, '%H:%M:%S').time()
        else:
            initvalue_ = default
        self.default = initvalue_
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if timeType.subclass:
            return timeType.subclass(*args_, **kwargs_)
        else:
            return timeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='timeType', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='timeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='timeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='timeType'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_time(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "QTime" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='timeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = self.gds_parse_time(value)
            except ValueError as exp:
                raise ValueError('Bad time attribute (default): %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class timeType


class dateTimeType(GeneratedsSuper):
    """A date and a time.Default value for the column.The type to use to
    represent this column in a Qt source file."""
    member_data_items_ = {
        'default': MemberSpec_('default', 'xs:time', 0),
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, default=None, defaultExpression=None, qtype='QDateTime'):
        self.original_tagname_ = None
        if isinstance(default, basestring):
            initvalue_ = datetime_.datetime.strptime(default, '%H:%M:%S').time()
        else:
            initvalue_ = default
        self.default = initvalue_
        self.defaultExpression = _cast(None, defaultExpression)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if dateTimeType.subclass:
            return dateTimeType.subclass(*args_, **kwargs_)
        else:
            return dateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='dateTimeType', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='dateTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='dateTimeType'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_time(self.default, input_name='default'))
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.qtype != "QDateTime" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='dateTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            try:
                self.default = self.gds_parse_time(value)
            except ValueError as exp:
                raise ValueError('Bad time attribute (default): %s' % exp)
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateTimeType


class char(GeneratedsSuper):
    """TODO: What is this?The length may be an integer (1-8000) or it may
    be `max` to use the largest possible value.The type to use to
    represent this column in a Qt source file."""
    member_data_items_ = {
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'default': MemberSpec_('default', 'xs:string', 0),
        'length': MemberSpec_('length', 'charLength', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, defaultExpression=None, default=None, length=None, qtype='QString'):
        self.original_tagname_ = None
        self.defaultExpression = _cast(None, defaultExpression)
        self.default = _cast(None, default)
        self.length = _cast(None, length)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if char.subclass:
            return char.subclass(*args_, **kwargs_)
        else:
            return char(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def validate_charLength(self, value):
        # Validate type charLength, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='char', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='char')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='char', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='char'):
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        if self.qtype != "QString" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='char', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            self.default = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            self.length = value
            self.validate_charLength(self.length)    # validate type charLength
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class char


class binary(GeneratedsSuper):
    """TODO: What is this?The length may be an integer (1-8000) or it may
    be `max` to use the largest possible value.The type to use to
    represent this column in a Qt source file."""
    member_data_items_ = {
        'length': MemberSpec_('length', 'charLength', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, length=None, qtype='QByteArray'):
        self.original_tagname_ = None
        self.length = _cast(None, length)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if binary.subclass:
            return binary.subclass(*args_, **kwargs_)
        else:
            return binary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def validate_charLength(self, value):
        # Validate type charLength, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='binary', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='binary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='binary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='binary'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        if self.qtype != "QByteArray" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='binary', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            self.length = value
            self.validate_charLength(self.length)    # validate type charLength
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class binary


class nchar(GeneratedsSuper):
    """TODO: What is this?Maximum number of characters (an integer in
    1-4000 range) or `max` to use maximum length.The type to use to
    represent this column in a Qt source file."""
    member_data_items_ = {
        'defaultExpression': MemberSpec_('defaultExpression', 'xs:string', 0),
        'default': MemberSpec_('default', 'xs:string', 0),
        'length': MemberSpec_('length', 'ncharLength', 0),
        'qtype': MemberSpec_('qtype', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, defaultExpression=None, default=None, length=None, qtype='QByteArray'):
        self.original_tagname_ = None
        self.defaultExpression = _cast(None, defaultExpression)
        self.default = _cast(None, default)
        self.length = _cast(None, length)
        self.qtype = _cast(None, qtype)
    def factory(*args_, **kwargs_):
        if nchar.subclass:
            return nchar.subclass(*args_, **kwargs_)
        else:
            return nchar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultExpression(self): return self.defaultExpression
    def set_defaultExpression(self, defaultExpression): self.defaultExpression = defaultExpression
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def validate_ncharLength(self, value):
        # Validate type ncharLength, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='nchar', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nchar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='nchar', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='nchar'):
        if self.defaultExpression is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            outfile.write(' defaultExpression=%s' % (self.gds_format_string(quote_attrib(self.defaultExpression).encode(ExternalEncoding), input_name='defaultExpression'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        if self.qtype != "QByteArray" and 'qtype' not in already_processed:
            already_processed.add('qtype')
            outfile.write(' qtype=%s' % (self.gds_format_string(quote_attrib(self.qtype).encode(ExternalEncoding), input_name='qtype'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='nchar', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultExpression', node)
        if value is not None and 'defaultExpression' not in already_processed:
            already_processed.add('defaultExpression')
            self.defaultExpression = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            self.default = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            self.length = value
            self.validate_ncharLength(self.length)    # validate type ncharLength
        value = find_attr_value_('qtype', node)
        if value is not None and 'qtype' not in already_processed:
            already_processed.add('qtype')
            self.qtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nchar


class column(GeneratedsSuper):
    """A column in a table. Name of this column as it will be known to the
    database.User visible string; if not provided `name` is
    used.Formatting options for when the value is presented to the
    user. The content depends on the type of value: bit: May be Yes,
    yes, On, on, True, true or another string; in latter case the
    string is shown if the value is true (1) and is hidden if the
    value is false (0) decimal, float, numeric, real, etc:
    fieldWidth`format`precision`fillChar Four values are used and
    are delimited by the ` character. fieldWidth is the minimum
    width of the generated text format can be e (format as
    [-]9.9e[+|-]999), E (format as [-]9.9E[+|-]999), f (format as
    [-]9.9), g (use e or f format, whichever is the most concise)
    and G (use E or f format, whichever is the most concise)
    precision number of digits after the decimal point or maximum
    number of significant digits fillChar is the character used to
    fill the space defined by fieldWidth For example 0`f`2` will
    present number -1.25687 as -1.26 int, smallint, bigint, tinyint
    fieldWidth`base`fillChar Three values are used and are delimited
    by the ` character. fieldWidth is the minimum width of the
    generated text base numeric base fillChar is the character used
    to fill the space defined by fieldWidth For example 0`10` will
    present number 1234 as 1234 text, varchar, etc The value of the
    format is used as input mask; see inputMask. Should the user be
    able to edit this column?.Does this column allows NULL values or
    not?If this column references a column in another table, this is
    the name of that table. This is the attribute to check if the
    column is a foreign key or not.If this column references a
    column in another table, this is the name of that column.If this
    column references a column in another table, this attribute
    decides which column (or columns) get inserted into what is
    shown to the user in place or the original column. The value may
    be a comma-separated list of column names."""
    member_data_items_ = {
        'foreignInsert': MemberSpec_('foreignInsert', 'xs:string', 0),
        'name': MemberSpec_('name', 'xs:string', 0),
        'foreignTable': MemberSpec_('foreignTable', 'xs:string', 0),
        'label': MemberSpec_('label', 'xs:string', 0),
        'allowNulls': MemberSpec_('allowNulls', 'xs:boolean', 0),
        'readOnly': MemberSpec_('readOnly', 'xs:boolean', 0),
        'foreignColumn': MemberSpec_('foreignColumn', 'xs:string', 0),
        'userformat': MemberSpec_('userformat', 'xs:string', 0),
        'bit': MemberSpec_('bit', 'bit', 0),
        'integer': MemberSpec_('integer', 'int', 0),
        'bigint': MemberSpec_('bigint', 'bigint', 0),
        'smallint': MemberSpec_('smallint', 'smallint', 0),
        'tinyint': MemberSpec_('tinyint', 'tinyint', 0),
        'numeric': MemberSpec_('numeric', 'decimal', 0),
        'decimal': MemberSpec_('decimal', 'decimal', 0),
        'numericScale0': MemberSpec_('numericScale0', 'decimalScale0', 0),
        'decimalScale0': MemberSpec_('decimalScale0', 'decimalScale0', 0),
        'smallmoney': MemberSpec_('smallmoney', 'smallmoney', 0),
        'money': MemberSpec_('money', 'money', 0),
        'float_': MemberSpec_('float_', 'float', 0),
        'real': MemberSpec_('real', 'real', 0),
        'date': MemberSpec_('date', 'dateType', 0),
        'datetime': MemberSpec_('datetime', 'dateTimeType', 0),
        'time': MemberSpec_('time', 'timeType', 0),
        'datetimeoffset': MemberSpec_('datetimeoffset', 'variablePrecisionTime', 0),
        'datetime2': MemberSpec_('datetime2', 'variablePrecisionTime', 0),
        'smalldatetime': MemberSpec_('smalldatetime', 'parameterlessStringType', 0),
        'char': MemberSpec_('char', 'char', 0),
        'varchar': MemberSpec_('varchar', 'char', 0),
        'text': MemberSpec_('text', 'parameterlessStringType', 0),
        'nchar': MemberSpec_('nchar', 'nchar', 0),
        'nvarchar': MemberSpec_('nvarchar', 'nchar', 0),
        'ntext': MemberSpec_('ntext', 'parameterlessStringType', 0),
        'binary': MemberSpec_('binary', 'binary', 0),
        'varbinary': MemberSpec_('varbinary', 'binary', 0),
        'image': MemberSpec_('image', 'parameterlessType', 0),
        'rowversion': MemberSpec_('rowversion', 'parameterlessType', 0),
        'hierarchyid': MemberSpec_('hierarchyid', 'parameterlessStringType', 0),
        'uniqueidentifier': MemberSpec_('uniqueidentifier', 'uniqueidentifier', 0),
        'sql_variant': MemberSpec_('sql_variant', 'parameterlessStringType', 0),
        'xml': MemberSpec_('xml', 'parameterlessStringType', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, foreignInsert='id', name=None, foreignTable=None, label=None, allowNulls=True, readOnly=False, foreignColumn='id', userformat='', bit=None, integer=None, bigint=None, smallint=None, tinyint=None, numeric=None, decimal=None, numericScale0=None, decimalScale0=None, smallmoney=None, money=None, float_=None, real=None, date=None, datetime=None, time=None, datetimeoffset=None, datetime2=None, smalldatetime=None, char=None, varchar=None, text=None, nchar=None, nvarchar=None, ntext=None, binary=None, varbinary=None, image=None, rowversion=None, hierarchyid=None, uniqueidentifier=None, sql_variant=None, xml=None):
        self.original_tagname_ = None
        self.foreignInsert = _cast(None, foreignInsert)
        self.name = _cast(None, name)
        self.foreignTable = _cast(None, foreignTable)
        self.label = _cast(None, label)
        self.allowNulls = _cast(bool, allowNulls)
        self.readOnly = _cast(bool, readOnly)
        self.foreignColumn = _cast(None, foreignColumn)
        self.userformat = _cast(None, userformat)
        self.bit = bit
        self.integer = integer
        self.bigint = bigint
        self.smallint = smallint
        self.tinyint = tinyint
        self.numeric = numeric
        self.decimal = decimal
        self.numericScale0 = numericScale0
        self.decimalScale0 = decimalScale0
        self.smallmoney = smallmoney
        self.money = money
        self.float_ = float_
        self.real = real
        self.date = date
        self.datetime = datetime
        self.time = time
        self.datetimeoffset = datetimeoffset
        self.datetime2 = datetime2
        self.smalldatetime = smalldatetime
        self.char = char
        self.varchar = varchar
        self.text = text
        self.nchar = nchar
        self.nvarchar = nvarchar
        self.ntext = ntext
        self.binary = binary
        self.varbinary = varbinary
        self.image = image
        self.rowversion = rowversion
        self.hierarchyid = hierarchyid
        self.uniqueidentifier = uniqueidentifier
        self.sql_variant = sql_variant
        self.xml = xml
    def factory(*args_, **kwargs_):
        if column.subclass:
            return column.subclass(*args_, **kwargs_)
        else:
            return column(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bit(self): return self.bit
    def set_bit(self, bit): self.bit = bit
    def get_integer(self): return self.integer
    def set_integer(self, integer): self.integer = integer
    def get_bigint(self): return self.bigint
    def set_bigint(self, bigint): self.bigint = bigint
    def get_smallint(self): return self.smallint
    def set_smallint(self, smallint): self.smallint = smallint
    def get_tinyint(self): return self.tinyint
    def set_tinyint(self, tinyint): self.tinyint = tinyint
    def get_numeric(self): return self.numeric
    def set_numeric(self, numeric): self.numeric = numeric
    def get_decimal(self): return self.decimal
    def set_decimal(self, decimal): self.decimal = decimal
    def get_numericScale0(self): return self.numericScale0
    def set_numericScale0(self, numericScale0): self.numericScale0 = numericScale0
    def get_decimalScale0(self): return self.decimalScale0
    def set_decimalScale0(self, decimalScale0): self.decimalScale0 = decimalScale0
    def get_smallmoney(self): return self.smallmoney
    def set_smallmoney(self, smallmoney): self.smallmoney = smallmoney
    def get_money(self): return self.money
    def set_money(self, money): self.money = money
    def get_float(self): return self.float_
    def set_float(self, float_): self.float_ = float_
    def get_real(self): return self.real
    def set_real(self, real): self.real = real
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_datetime(self): return self.datetime
    def set_datetime(self, datetime): self.datetime = datetime
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_datetimeoffset(self): return self.datetimeoffset
    def set_datetimeoffset(self, datetimeoffset): self.datetimeoffset = datetimeoffset
    def get_datetime2(self): return self.datetime2
    def set_datetime2(self, datetime2): self.datetime2 = datetime2
    def get_smalldatetime(self): return self.smalldatetime
    def set_smalldatetime(self, smalldatetime): self.smalldatetime = smalldatetime
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_varchar(self): return self.varchar
    def set_varchar(self, varchar): self.varchar = varchar
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_nchar(self): return self.nchar
    def set_nchar(self, nchar): self.nchar = nchar
    def get_nvarchar(self): return self.nvarchar
    def set_nvarchar(self, nvarchar): self.nvarchar = nvarchar
    def get_ntext(self): return self.ntext
    def set_ntext(self, ntext): self.ntext = ntext
    def get_binary(self): return self.binary
    def set_binary(self, binary): self.binary = binary
    def get_varbinary(self): return self.varbinary
    def set_varbinary(self, varbinary): self.varbinary = varbinary
    def get_image(self): return self.image
    def set_image(self, image): self.image = image
    def get_rowversion(self): return self.rowversion
    def set_rowversion(self, rowversion): self.rowversion = rowversion
    def get_hierarchyid(self): return self.hierarchyid
    def set_hierarchyid(self, hierarchyid): self.hierarchyid = hierarchyid
    def get_uniqueidentifier(self): return self.uniqueidentifier
    def set_uniqueidentifier(self, uniqueidentifier): self.uniqueidentifier = uniqueidentifier
    def get_sql_variant(self): return self.sql_variant
    def set_sql_variant(self, sql_variant): self.sql_variant = sql_variant
    def get_xml(self): return self.xml
    def set_xml(self, xml): self.xml = xml
    def get_foreignInsert(self): return self.foreignInsert
    def set_foreignInsert(self, foreignInsert): self.foreignInsert = foreignInsert
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_foreignTable(self): return self.foreignTable
    def set_foreignTable(self, foreignTable): self.foreignTable = foreignTable
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_allowNulls(self): return self.allowNulls
    def set_allowNulls(self, allowNulls): self.allowNulls = allowNulls
    def get_readOnly(self): return self.readOnly
    def set_readOnly(self, readOnly): self.readOnly = readOnly
    def get_foreignColumn(self): return self.foreignColumn
    def set_foreignColumn(self, foreignColumn): self.foreignColumn = foreignColumn
    def get_userformat(self): return self.userformat
    def set_userformat(self, userformat): self.userformat = userformat
    def hasContent_(self):
        if (
            self.bit is not None or
            self.integer is not None or
            self.bigint is not None or
            self.smallint is not None or
            self.tinyint is not None or
            self.numeric is not None or
            self.decimal is not None or
            self.numericScale0 is not None or
            self.decimalScale0 is not None or
            self.smallmoney is not None or
            self.money is not None or
            self.float_ is not None or
            self.real is not None or
            self.date is not None or
            self.datetime is not None or
            self.time is not None or
            self.datetimeoffset is not None or
            self.datetime2 is not None or
            self.smalldatetime is not None or
            self.char is not None or
            self.varchar is not None or
            self.text is not None or
            self.nchar is not None or
            self.nvarchar is not None or
            self.ntext is not None or
            self.binary is not None or
            self.varbinary is not None or
            self.image is not None or
            self.rowversion is not None or
            self.hierarchyid is not None or
            self.uniqueidentifier is not None or
            self.sql_variant is not None or
            self.xml is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='column', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='column')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='column', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='column'):
        if self.foreignInsert != "id" and 'foreignInsert' not in already_processed:
            already_processed.add('foreignInsert')
            outfile.write(' foreignInsert=%s' % (self.gds_format_string(quote_attrib(self.foreignInsert).encode(ExternalEncoding), input_name='foreignInsert'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.foreignTable is not None and 'foreignTable' not in already_processed:
            already_processed.add('foreignTable')
            outfile.write(' foreignTable=%s' % (self.gds_format_string(quote_attrib(self.foreignTable).encode(ExternalEncoding), input_name='foreignTable'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if not self.allowNulls and 'allowNulls' not in already_processed:
            already_processed.add('allowNulls')
            outfile.write(' allowNulls="%s"' % self.gds_format_boolean(self.allowNulls, input_name='allowNulls'))
        if self.readOnly and 'readOnly' not in already_processed:
            already_processed.add('readOnly')
            outfile.write(' readOnly="%s"' % self.gds_format_boolean(self.readOnly, input_name='readOnly'))
        if self.foreignColumn != "id" and 'foreignColumn' not in already_processed:
            already_processed.add('foreignColumn')
            outfile.write(' foreignColumn=%s' % (self.gds_format_string(quote_attrib(self.foreignColumn).encode(ExternalEncoding), input_name='foreignColumn'), ))
        if self.userformat != "" and 'userformat' not in already_processed:
            already_processed.add('userformat')
            outfile.write(' userformat=%s' % (self.gds_format_string(quote_attrib(self.userformat).encode(ExternalEncoding), input_name='userformat'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='column', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bit is not None:
            self.bit.export(outfile, level, namespace_, name_='bit', pretty_print=pretty_print)
        if self.integer is not None:
            self.integer.export(outfile, level, namespace_, name_='int', pretty_print=pretty_print)
        if self.bigint is not None:
            self.bigint.export(outfile, level, namespace_, name_='bigint', pretty_print=pretty_print)
        if self.smallint is not None:
            self.smallint.export(outfile, level, namespace_, name_='smallint', pretty_print=pretty_print)
        if self.tinyint is not None:
            self.tinyint.export(outfile, level, namespace_, name_='tinyint', pretty_print=pretty_print)
        if self.numeric is not None:
            self.numeric.export(outfile, level, namespace_, name_='numeric', pretty_print=pretty_print)
        if self.decimal is not None:
            self.decimal.export(outfile, level, namespace_, name_='decimal', pretty_print=pretty_print)
        if self.numericScale0 is not None:
            self.numericScale0.export(outfile, level, namespace_, name_='numericScale0', pretty_print=pretty_print)
        if self.decimalScale0 is not None:
            self.decimalScale0.export(outfile, level, namespace_, name_='decimalScale0', pretty_print=pretty_print)
        if self.smallmoney is not None:
            self.smallmoney.export(outfile, level, namespace_, name_='smallmoney', pretty_print=pretty_print)
        if self.money is not None:
            self.money.export(outfile, level, namespace_, name_='money', pretty_print=pretty_print)
        if self.float_ is not None:
            self.float_.export(outfile, level, namespace_, name_='float', pretty_print=pretty_print)
        if self.real is not None:
            self.real.export(outfile, level, namespace_, name_='real', pretty_print=pretty_print)
        if self.date is not None:
            self.date.export(outfile, level, namespace_, name_='date', pretty_print=pretty_print)
        if self.datetime is not None:
            self.datetime.export(outfile, level, namespace_, name_='datetime', pretty_print=pretty_print)
        if self.time is not None:
            self.time.export(outfile, level, namespace_, name_='time', pretty_print=pretty_print)
        if self.datetimeoffset is not None:
            self.datetimeoffset.export(outfile, level, namespace_, name_='datetimeoffset', pretty_print=pretty_print)
        if self.datetime2 is not None:
            self.datetime2.export(outfile, level, namespace_, name_='datetime2', pretty_print=pretty_print)
        if self.smalldatetime is not None:
            self.smalldatetime.export(outfile, level, namespace_, name_='smalldatetime', pretty_print=pretty_print)
        if self.char is not None:
            self.char.export(outfile, level, namespace_, name_='char', pretty_print=pretty_print)
        if self.varchar is not None:
            self.varchar.export(outfile, level, namespace_, name_='varchar', pretty_print=pretty_print)
        if self.text is not None:
            self.text.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
        if self.nchar is not None:
            self.nchar.export(outfile, level, namespace_, name_='nchar', pretty_print=pretty_print)
        if self.nvarchar is not None:
            self.nvarchar.export(outfile, level, namespace_, name_='nvarchar', pretty_print=pretty_print)
        if self.ntext is not None:
            self.ntext.export(outfile, level, namespace_, name_='ntext', pretty_print=pretty_print)
        if self.binary is not None:
            self.binary.export(outfile, level, namespace_, name_='binary', pretty_print=pretty_print)
        if self.varbinary is not None:
            self.varbinary.export(outfile, level, namespace_, name_='varbinary', pretty_print=pretty_print)
        if self.image is not None:
            self.image.export(outfile, level, namespace_, name_='image', pretty_print=pretty_print)
        if self.rowversion is not None:
            self.rowversion.export(outfile, level, namespace_, name_='rowversion', pretty_print=pretty_print)
        if self.hierarchyid is not None:
            self.hierarchyid.export(outfile, level, namespace_, name_='hierarchyid', pretty_print=pretty_print)
        if self.uniqueidentifier is not None:
            self.uniqueidentifier.export(outfile, level, namespace_, name_='uniqueidentifier', pretty_print=pretty_print)
        if self.sql_variant is not None:
            self.sql_variant.export(outfile, level, namespace_, name_='sql_variant', pretty_print=pretty_print)
        if self.xml is not None:
            self.xml.export(outfile, level, namespace_, name_='xml', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('foreignInsert', node)
        if value is not None and 'foreignInsert' not in already_processed:
            already_processed.add('foreignInsert')
            self.foreignInsert = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('foreignTable', node)
        if value is not None and 'foreignTable' not in already_processed:
            already_processed.add('foreignTable')
            self.foreignTable = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('allowNulls', node)
        if value is not None and 'allowNulls' not in already_processed:
            already_processed.add('allowNulls')
            if value in ('true', '1'):
                self.allowNulls = True
            elif value in ('false', '0'):
                self.allowNulls = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('readOnly', node)
        if value is not None and 'readOnly' not in already_processed:
            already_processed.add('readOnly')
            if value in ('true', '1'):
                self.readOnly = True
            elif value in ('false', '0'):
                self.readOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('foreignColumn', node)
        if value is not None and 'foreignColumn' not in already_processed:
            already_processed.add('foreignColumn')
            self.foreignColumn = value
        value = find_attr_value_('userformat', node)
        if value is not None and 'userformat' not in already_processed:
            already_processed.add('userformat')
            self.userformat = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bit':
            obj_ = bit.factory()
            obj_.build(child_)
            self.bit = obj_
            obj_.original_tagname_ = 'bit'
        elif nodeName_ == 'int':
            obj_ = integer.factory()
            obj_.build(child_)
            self.integer = obj_
            obj_.original_tagname_ = 'int'
        elif nodeName_ == 'bigint':
            obj_ = bigint.factory()
            obj_.build(child_)
            self.bigint = obj_
            obj_.original_tagname_ = 'bigint'
        elif nodeName_ == 'smallint':
            obj_ = smallint.factory()
            obj_.build(child_)
            self.smallint = obj_
            obj_.original_tagname_ = 'smallint'
        elif nodeName_ == 'tinyint':
            obj_ = tinyint.factory()
            obj_.build(child_)
            self.tinyint = obj_
            obj_.original_tagname_ = 'tinyint'
        elif nodeName_ == 'numeric':
            obj_ = decimal.factory()
            obj_.build(child_)
            self.numeric = obj_
            obj_.original_tagname_ = 'numeric'
        elif nodeName_ == 'decimal':
            obj_ = decimal.factory()
            obj_.build(child_)
            self.decimal = obj_
            obj_.original_tagname_ = 'decimal'
        elif nodeName_ == 'numericScale0':
            obj_ = decimalScale0.factory()
            obj_.build(child_)
            self.numericScale0 = obj_
            obj_.original_tagname_ = 'numericScale0'
        elif nodeName_ == 'decimalScale0':
            obj_ = decimalScale0.factory()
            obj_.build(child_)
            self.decimalScale0 = obj_
            obj_.original_tagname_ = 'decimalScale0'
        elif nodeName_ == 'smallmoney':
            obj_ = smallmoney.factory()
            obj_.build(child_)
            self.smallmoney = obj_
            obj_.original_tagname_ = 'smallmoney'
        elif nodeName_ == 'money':
            obj_ = money.factory()
            obj_.build(child_)
            self.money = obj_
            obj_.original_tagname_ = 'money'
        elif nodeName_ == 'float':
            obj_ = float_.factory()
            obj_.build(child_)
            self.float_ = obj_
            obj_.original_tagname_ = 'float'
        elif nodeName_ == 'real':
            obj_ = real.factory()
            obj_.build(child_)
            self.real = obj_
            obj_.original_tagname_ = 'real'
        elif nodeName_ == 'date':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.date = obj_
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'datetime':
            obj_ = dateTimeType.factory()
            obj_.build(child_)
            self.datetime = obj_
            obj_.original_tagname_ = 'datetime'
        elif nodeName_ == 'time':
            obj_ = timeType.factory()
            obj_.build(child_)
            self.time = obj_
            obj_.original_tagname_ = 'time'
        elif nodeName_ == 'datetimeoffset':
            obj_ = variablePrecisionTime.factory()
            obj_.build(child_)
            self.datetimeoffset = obj_
            obj_.original_tagname_ = 'datetimeoffset'
        elif nodeName_ == 'datetime2':
            obj_ = variablePrecisionTime.factory()
            obj_.build(child_)
            self.datetime2 = obj_
            obj_.original_tagname_ = 'datetime2'
        elif nodeName_ == 'smalldatetime':
            obj_ = parameterlessStringType.factory()
            obj_.build(child_)
            self.smalldatetime = obj_
            obj_.original_tagname_ = 'smalldatetime'
        elif nodeName_ == 'char':
            obj_ = char.factory()
            obj_.build(child_)
            self.char = obj_
            obj_.original_tagname_ = 'char'
        elif nodeName_ == 'varchar':
            obj_ = char.factory()
            obj_.build(child_)
            self.varchar = obj_
            obj_.original_tagname_ = 'varchar'
        elif nodeName_ == 'text':
            obj_ = parameterlessStringType.factory()
            obj_.build(child_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
        elif nodeName_ == 'nchar':
            obj_ = nchar.factory()
            obj_.build(child_)
            self.nchar = obj_
            obj_.original_tagname_ = 'nchar'
        elif nodeName_ == 'nvarchar':
            obj_ = nchar.factory()
            obj_.build(child_)
            self.nvarchar = obj_
            obj_.original_tagname_ = 'nvarchar'
        elif nodeName_ == 'ntext':
            obj_ = parameterlessStringType.factory()
            obj_.build(child_)
            self.ntext = obj_
            obj_.original_tagname_ = 'ntext'
        elif nodeName_ == 'binary':
            obj_ = binary.factory()
            obj_.build(child_)
            self.binary = obj_
            obj_.original_tagname_ = 'binary'
        elif nodeName_ == 'varbinary':
            obj_ = binary.factory()
            obj_.build(child_)
            self.varbinary = obj_
            obj_.original_tagname_ = 'varbinary'
        elif nodeName_ == 'image':
            obj_ = parameterlessType.factory()
            obj_.build(child_)
            self.image = obj_
            obj_.original_tagname_ = 'image'
        elif nodeName_ == 'rowversion':
            obj_ = parameterlessType.factory()
            obj_.build(child_)
            self.rowversion = obj_
            obj_.original_tagname_ = 'rowversion'
        elif nodeName_ == 'hierarchyid':
            obj_ = parameterlessStringType.factory()
            obj_.build(child_)
            self.hierarchyid = obj_
            obj_.original_tagname_ = 'hierarchyid'
        elif nodeName_ == 'uniqueidentifier':
            obj_ = uniqueidentifier.factory()
            obj_.build(child_)
            self.uniqueidentifier = obj_
            obj_.original_tagname_ = 'uniqueidentifier'
        elif nodeName_ == 'sql_variant':
            obj_ = parameterlessStringType.factory()
            obj_.build(child_)
            self.sql_variant = obj_
            obj_.original_tagname_ = 'sql_variant'
        elif nodeName_ == 'xml':
            obj_ = parameterlessStringType.factory()
            obj_.build(child_)
            self.xml = obj_
            obj_.original_tagname_ = 'xml'
# end class column


class columnList(GeneratedsSuper):
    """The list of columns for a table."""
    member_data_items_ = {
        'column': MemberSpec_('column', 'column', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, column=None):
        self.original_tagname_ = None
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if columnList.subclass:
            return columnList.subclass(*args_, **kwargs_)
        else:
            return columnList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column_at(self, index, value): self.column.insert(index, value)
    def replace_column_at(self, index, value): self.column[index] = value
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='columnList', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='columnList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='columnList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='columnList'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='columnList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class columnList


class constraintColumn(GeneratedsSuper):
    """A column that is part of a constraint.The name of the column.The
    order used to sort the column."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0),
        'sortOrder': MemberSpec_('sortOrder', 'sortOrder', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, sortOrder=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.sortOrder = _cast(None, sortOrder)
    def factory(*args_, **kwargs_):
        if constraintColumn.subclass:
            return constraintColumn.subclass(*args_, **kwargs_)
        else:
            return constraintColumn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sortOrder(self): return self.sortOrder
    def set_sortOrder(self, sortOrder): self.sortOrder = sortOrder
    def validate_sortOrder(self, value):
        # Validate type sortOrder, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Ascending', 'Descending']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on sortOrder' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='constraintColumn', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constraintColumn')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='constraintColumn', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='constraintColumn'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sortOrder is not None and 'sortOrder' not in already_processed:
            already_processed.add('sortOrder')
            outfile.write(' sortOrder=%s' % (quote_attrib(self.sortOrder), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='constraintColumn', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('sortOrder', node)
        if value is not None and 'sortOrder' not in already_processed:
            already_processed.add('sortOrder')
            self.sortOrder = value
            self.validate_sortOrder(self.sortOrder)    # validate type sortOrder
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class constraintColumn


class constraint(GeneratedsSuper):
    """A column(s) based constraint.Name of the constraint.TODO: what is
    this?TODO: what is this?TODO: what is this?"""
    member_data_items_ = {
        'clustered': MemberSpec_('clustered', 'xs:boolean', 0),
        'padIndex': MemberSpec_('padIndex', 'xs:boolean', 0),
        'fillFactor': MemberSpec_('fillFactor', 'xs:integer', 0),
        'name': MemberSpec_('name', 'xs:string', 0),
        'column': MemberSpec_('column', 'column', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, clustered=None, padIndex=None, fillFactor=None, name=None, column=None, extensiontype_=None):
        self.original_tagname_ = None
        self.clustered = _cast(bool, clustered)
        self.padIndex = _cast(bool, padIndex)
        self.fillFactor = _cast(int, fillFactor)
        self.name = _cast(None, name)
        if column is None:
            self.column = []
        else:
            self.column = column
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if constraint.subclass:
            return constraint.subclass(*args_, **kwargs_)
        else:
            return constraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column_at(self, index, value): self.column.insert(index, value)
    def replace_column_at(self, index, value): self.column[index] = value
    def get_clustered(self): return self.clustered
    def set_clustered(self, clustered): self.clustered = clustered
    def get_padIndex(self): return self.padIndex
    def set_padIndex(self, padIndex): self.padIndex = padIndex
    def get_fillFactor(self): return self.fillFactor
    def set_fillFactor(self, fillFactor): self.fillFactor = fillFactor
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='constraint', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constraint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='constraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='constraint'):
        if self.clustered is not None and 'clustered' not in already_processed:
            already_processed.add('clustered')
            outfile.write(' clustered="%s"' % self.gds_format_boolean(self.clustered, input_name='clustered'))
        if self.padIndex is not None and 'padIndex' not in already_processed:
            already_processed.add('padIndex')
            outfile.write(' padIndex="%s"' % self.gds_format_boolean(self.padIndex, input_name='padIndex'))
        if self.fillFactor is not None and 'fillFactor' not in already_processed:
            already_processed.add('fillFactor')
            outfile.write(' fillFactor="%s"' % self.gds_format_integer(self.fillFactor, input_name='fillFactor'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='constraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clustered', node)
        if value is not None and 'clustered' not in already_processed:
            already_processed.add('clustered')
            if value in ('true', '1'):
                self.clustered = True
            elif value in ('false', '0'):
                self.clustered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('padIndex', node)
        if value is not None and 'padIndex' not in already_processed:
            already_processed.add('padIndex')
            if value in ('true', '1'):
                self.padIndex = True
            elif value in ('false', '0'):
                self.padIndex = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('fillFactor', node)
        if value is not None and 'fillFactor' not in already_processed:
            already_processed.add('fillFactor')
            try:
                self.fillFactor = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = constraintColumn.factory()
            obj_.build(child_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class constraint


class primaryKey(GeneratedsSuper):
    """The (optional) primary key for a table."""
    member_data_items_ = {
        'key': MemberSpec_('key', 'constraint', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, key=None):
        self.original_tagname_ = None
        self.key = key
    def factory(*args_, **kwargs_):
        if primaryKey.subclass:
            return primaryKey.subclass(*args_, **kwargs_)
        else:
            return primaryKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def hasContent_(self):
        if (
            self.key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='primaryKey', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='primaryKey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='primaryKey', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='primaryKey'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='primaryKey', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.key is not None:
            self.key.export(outfile, level, namespace_, name_='key', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key':
            class_obj_ = self.get_class_obj_(child_, constraint)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.key = obj_
            obj_.original_tagname_ = 'key'
# end class primaryKey


class uniqueConstraints(GeneratedsSuper):
    """The list of unique constraints associated with a table."""
    member_data_items_ = {
        'constraint': MemberSpec_('constraint', 'constraint', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, constraint=None):
        self.original_tagname_ = None
        if constraint is None:
            self.constraint = []
        else:
            self.constraint = constraint
    def factory(*args_, **kwargs_):
        if uniqueConstraints.subclass:
            return uniqueConstraints.subclass(*args_, **kwargs_)
        else:
            return uniqueConstraints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constraint(self): return self.constraint
    def set_constraint(self, constraint): self.constraint = constraint
    def add_constraint(self, value): self.constraint.append(value)
    def insert_constraint_at(self, index, value): self.constraint.insert(index, value)
    def replace_constraint_at(self, index, value): self.constraint[index] = value
    def hasContent_(self):
        if (
            self.constraint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='uniqueConstraints', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uniqueConstraints')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='uniqueConstraints', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='uniqueConstraints'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='uniqueConstraints', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constraint_ in self.constraint:
            constraint_.export(outfile, level, namespace_, name_='constraint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constraint':
            class_obj_ = self.get_class_obj_(child_, constraint)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.constraint.append(obj_)
            obj_.original_tagname_ = 'constraint'
# end class uniqueConstraints


class index(constraint):
    """One entry in the list of indexes in a table."""
    member_data_items_ = {
        'unique': MemberSpec_('unique', 'xs:boolean', 0),
    }
    subclass = None
    superclass = constraint
    def __init__(self, clustered=None, padIndex=None, fillFactor=None, name=None, column=None, unique=None):
        self.original_tagname_ = None
        super(index, self).__init__(clustered, padIndex, fillFactor, name, column, )
        self.unique = _cast(bool, unique)
    def factory(*args_, **kwargs_):
        if index.subclass:
            return index.subclass(*args_, **kwargs_)
        else:
            return index(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def hasContent_(self):
        if (
            super(index, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='index', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='index')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='index', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='index'):
        super(index, self).exportAttributes(outfile, level, already_processed, namespace_, name_='index')
        if self.unique is not None and 'unique' not in already_processed:
            already_processed.add('unique')
            outfile.write(' unique="%s"' % self.gds_format_boolean(self.unique, input_name='unique'))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='index', fromsubclass_=False, pretty_print=True):
        super(index, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unique', node)
        if value is not None and 'unique' not in already_processed:
            already_processed.add('unique')
            if value in ('true', '1'):
                self.unique = True
            elif value in ('false', '0'):
                self.unique = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(index, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(index, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class index


class indexes(GeneratedsSuper):
    """The list of indexes in a table."""
    member_data_items_ = {
        'index': MemberSpec_('index', 'index', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, index=None):
        self.original_tagname_ = None
        if index is None:
            self.index = []
        else:
            self.index = index
    def factory(*args_, **kwargs_):
        if indexes.subclass:
            return indexes.subclass(*args_, **kwargs_)
        else:
            return indexes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def add_index(self, value): self.index.append(value)
    def insert_index_at(self, index, value): self.index.insert(index, value)
    def replace_index_at(self, index, value): self.index[index] = value
    def hasContent_(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='indexes', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indexes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='indexes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='indexes'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='indexes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            index_.export(outfile, level, namespace_, name_='index', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'index':
            obj_ = index.factory()
            obj_.build(child_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indexes


class relationshipColumn(GeneratedsSuper):
    """A column in a relationship.Name of the column."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if relationshipColumn.subclass:
            return relationshipColumn.subclass(*args_, **kwargs_)
        else:
            return relationshipColumn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='relationshipColumn', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relationshipColumn')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='relationshipColumn', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='relationshipColumn'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='relationshipColumn', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class relationshipColumn


class foreignKeyColumns(GeneratedsSuper):
    """The list of foreign keys."""
    member_data_items_ = {
        'column': MemberSpec_('column', 'column', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, column=None):
        self.original_tagname_ = None
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if foreignKeyColumns.subclass:
            return foreignKeyColumns.subclass(*args_, **kwargs_)
        else:
            return foreignKeyColumns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column_at(self, index, value): self.column.insert(index, value)
    def replace_column_at(self, index, value): self.column[index] = value
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='foreignKeyColumns', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='foreignKeyColumns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='foreignKeyColumns', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='foreignKeyColumns'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='foreignKeyColumns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = relationshipColumn.factory()
            obj_.build(child_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class foreignKeyColumns


class primaryKeyTable(GeneratedsSuper):
    """TODO: What is this?.Name of the table? TODO."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0),
        'column': MemberSpec_('column', 'column', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, column=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if primaryKeyTable.subclass:
            return primaryKeyTable.subclass(*args_, **kwargs_)
        else:
            return primaryKeyTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column_at(self, index, value): self.column.insert(index, value)
    def replace_column_at(self, index, value): self.column[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.column
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='primaryKeyTable', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='primaryKeyTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='primaryKeyTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='primaryKeyTable'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='primaryKeyTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = relationshipColumn.factory()
            obj_.build(child_)
            self.column.append(obj_)
            obj_.original_tagname_ = 'column'
# end class primaryKeyTable


class relationship(GeneratedsSuper):
    """A single relation for a table.Name of the relation."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0),
        'foreignKeyColumns': MemberSpec_('foreignKeyColumns', 'foreignKeyColumns', 0),
        'primaryKeyTable': MemberSpec_('primaryKeyTable', 'primaryKeyTable', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, foreignKeyColumns=None, primaryKeyTable=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.foreignKeyColumns = foreignKeyColumns
        self.primaryKeyTable = primaryKeyTable
    def factory(*args_, **kwargs_):
        if relationship.subclass:
            return relationship.subclass(*args_, **kwargs_)
        else:
            return relationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_foreignKeyColumns(self): return self.foreignKeyColumns
    def set_foreignKeyColumns(self, foreignKeyColumns): self.foreignKeyColumns = foreignKeyColumns
    def get_primaryKeyTable(self): return self.primaryKeyTable
    def set_primaryKeyTable(self, primaryKeyTable): self.primaryKeyTable = primaryKeyTable
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.foreignKeyColumns is not None or
            self.primaryKeyTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='relationship', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relationship')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='relationship', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='relationship'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='relationship', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.foreignKeyColumns is not None:
            self.foreignKeyColumns.export(outfile, level, namespace_, name_='foreignKeyColumns', pretty_print=pretty_print)
        if self.primaryKeyTable is not None:
            self.primaryKeyTable.export(outfile, level, namespace_, name_='primaryKeyTable', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'foreignKeyColumns':
            obj_ = foreignKeyColumns.factory()
            obj_.build(child_)
            self.foreignKeyColumns = obj_
            obj_.original_tagname_ = 'foreignKeyColumns'
        elif nodeName_ == 'primaryKeyTable':
            obj_ = primaryKeyTable.factory()
            obj_.build(child_)
            self.primaryKeyTable = obj_
            obj_.original_tagname_ = 'primaryKeyTable'
# end class relationship


class relationships(GeneratedsSuper):
    """List of relations for a table; can only consist of `relationship`
    entries."""
    member_data_items_ = {
        'relationship': MemberSpec_('relationship', 'relationship', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, relationship=None):
        self.original_tagname_ = None
        if relationship is None:
            self.relationship = []
        else:
            self.relationship = relationship
    def factory(*args_, **kwargs_):
        if relationships.subclass:
            return relationships.subclass(*args_, **kwargs_)
        else:
            return relationships(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relationship(self): return self.relationship
    def set_relationship(self, relationship): self.relationship = relationship
    def add_relationship(self, value): self.relationship.append(value)
    def insert_relationship_at(self, index, value): self.relationship.insert(index, value)
    def replace_relationship_at(self, index, value): self.relationship[index] = value
    def hasContent_(self):
        if (
            self.relationship
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='relationships', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relationships')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='relationships', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='relationships'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='relationships', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relationship_ in self.relationship:
            relationship_.export(outfile, level, namespace_, name_='relationship', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relationship':
            obj_ = relationship.factory()
            obj_.build(child_)
            self.relationship.append(obj_)
            obj_.original_tagname_ = 'relationship'
# end class relationships


class table(GeneratedsSuper):
    """An actual table (not view).Name of the table."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0),
        'columns': MemberSpec_('columns', 'columnList', 0),
        'primaryKey': MemberSpec_('primaryKey', 'primaryKey', 0),
        'uniqueConstraints': MemberSpec_('uniqueConstraints', 'uniqueConstraints', 0),
        'indexes': MemberSpec_('indexes', 'indexes', 0),
        'relationships': MemberSpec_('relationships', 'relationships', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, columns=None, primaryKey=None, uniqueConstraints=None, indexes=None, relationships=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.columns = columns
        self.primaryKey = primaryKey
        self.uniqueConstraints = uniqueConstraints
        self.indexes = indexes
        self.relationships = relationships
    def factory(*args_, **kwargs_):
        if table.subclass:
            return table.subclass(*args_, **kwargs_)
        else:
            return table(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_columns(self): return self.columns
    def set_columns(self, columns): self.columns = columns
    def get_primaryKey(self): return self.primaryKey
    def set_primaryKey(self, primaryKey): self.primaryKey = primaryKey
    def get_uniqueConstraints(self): return self.uniqueConstraints
    def set_uniqueConstraints(self, uniqueConstraints): self.uniqueConstraints = uniqueConstraints
    def get_indexes(self): return self.indexes
    def set_indexes(self, indexes): self.indexes = indexes
    def get_relationships(self): return self.relationships
    def set_relationships(self, relationships): self.relationships = relationships
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.columns is not None or
            self.primaryKey is not None or
            self.uniqueConstraints is not None or
            self.indexes is not None or
            self.relationships is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='table', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='table')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='table', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='table'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='table', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.columns is not None:
            self.columns.export(outfile, level, namespace_, name_='columns', pretty_print=pretty_print)
        if self.primaryKey is not None:
            self.primaryKey.export(outfile, level, namespace_, name_='primaryKey', pretty_print=pretty_print)
        if self.uniqueConstraints is not None:
            self.uniqueConstraints.export(outfile, level, namespace_, name_='uniqueConstraints', pretty_print=pretty_print)
        if self.indexes is not None:
            self.indexes.export(outfile, level, namespace_, name_='indexes', pretty_print=pretty_print)
        if self.relationships is not None:
            self.relationships.export(outfile, level, namespace_, name_='relationships', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'columns':
            obj_ = columnList.factory()
            obj_.build(child_)
            self.columns = obj_
            obj_.original_tagname_ = 'columns'
        elif nodeName_ == 'primaryKey':
            obj_ = primaryKey.factory()
            obj_.build(child_)
            self.primaryKey = obj_
            obj_.original_tagname_ = 'primaryKey'
        elif nodeName_ == 'uniqueConstraints':
            obj_ = uniqueConstraints.factory()
            obj_.build(child_)
            self.uniqueConstraints = obj_
            obj_.original_tagname_ = 'uniqueConstraints'
        elif nodeName_ == 'indexes':
            obj_ = indexes.factory()
            obj_.build(child_)
            self.indexes = obj_
            obj_.original_tagname_ = 'indexes'
        elif nodeName_ == 'relationships':
            obj_ = relationships.factory()
            obj_.build(child_)
            self.relationships = obj_
            obj_.original_tagname_ = 'relationships'
# end class table


class tables(GeneratedsSuper):
    """A single element inside the database; contains the list of actual
    tables (not views)."""
    member_data_items_ = {
        'table': MemberSpec_('table', 'table', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, table=None):
        self.original_tagname_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
    def factory(*args_, **kwargs_):
        if tables.subclass:
            return tables.subclass(*args_, **kwargs_)
        else:
            return tables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_table(self): return self.table
    def set_table(self, table): self.table = table
    def add_table(self, value): self.table.append(value)
    def insert_table_at(self, index, value): self.table.insert(index, value)
    def replace_table_at(self, index, value): self.table[index] = value
    def hasContent_(self):
        if (
            self.table
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='tables', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tables')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='tables', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='tables'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='tables', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for table_ in self.table:
            table_.export(outfile, level, namespace_, name_='table', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'table':
            obj_ = table.factory()
            obj_.build(child_)
            self.table.append(obj_)
            obj_.original_tagname_ = 'table'
# end class tables


class viewSubset(GeneratedsSuper):
    """One type of view is the subset view that simply extracts information
    from another table. It may act as a simple `SELECT * FROM name1
    WHERE col1=value` by using the `name1`, `col1`, `constraint` and
    `value` attributes. It may also act as `SELECT * FROM name1
    WHERE col1 IN (SELECT in FROM incol WHERE where=value)` by using
    additional attributes: `in`, `incol`, `where` attributes. Top
    level table from where we're selecting.Column in top level table
    from where we're selecting.Second level table used as source (of
    ids) for primary table.Column in second level table used as
    source for primary table.Column in second level table used to
    filter secondary table.Operator to apply to `value` and either
    `col1` or `where` depending on the variant that's being used.The
    value to compare using `constraint` against `col1` or `where`
    depending on the variant that's being used."""
    member_data_items_ = {
        'constraint': MemberSpec_('constraint', 'xs:string', 0),
        'name1': MemberSpec_('name1', 'xs:string', 0),
        'value': MemberSpec_('value', 'xs:string', 0),
        'col1': MemberSpec_('col1', 'xs:string', 0),
        'in': MemberSpec_('in', 'xs:string', 0),
        'incol': MemberSpec_('incol', 'xs:string', 0),
        'where': MemberSpec_('where', 'xs:string', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, constraint=None, name1=None, value=None, col1=None, in_=None, incol=None, where=None):
        self.original_tagname_ = None
        self.constraint = _cast(None, constraint)
        self.name1 = _cast(None, name1)
        self.value = _cast(None, value)
        self.col1 = _cast(None, col1)
        self.in_ = _cast(None, in_)
        self.incol = _cast(None, incol)
        self.where = _cast(None, where)
    def factory(*args_, **kwargs_):
        if viewSubset.subclass:
            return viewSubset.subclass(*args_, **kwargs_)
        else:
            return viewSubset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constraint(self): return self.constraint
    def set_constraint(self, constraint): self.constraint = constraint
    def get_name1(self): return self.name1
    def set_name1(self, name1): self.name1 = name1
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_col1(self): return self.col1
    def set_col1(self, col1): self.col1 = col1
    def get_in(self): return self.in_
    def set_in(self, in_): self.in_ = in_
    def get_incol(self): return self.incol
    def set_incol(self, incol): self.incol = incol
    def get_where(self): return self.where
    def set_where(self, where): self.where = where
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='viewSubset', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewSubset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='viewSubset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='viewSubset'):
        if self.constraint is not None and 'constraint' not in already_processed:
            already_processed.add('constraint')
            outfile.write(' constraint=%s' % (self.gds_format_string(quote_attrib(self.constraint).encode(ExternalEncoding), input_name='constraint'), ))
        if self.name1 is not None and 'name1' not in already_processed:
            already_processed.add('name1')
            outfile.write(' name1=%s' % (self.gds_format_string(quote_attrib(self.name1).encode(ExternalEncoding), input_name='name1'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.col1 is not None and 'col1' not in already_processed:
            already_processed.add('col1')
            outfile.write(' col1=%s' % (self.gds_format_string(quote_attrib(self.col1).encode(ExternalEncoding), input_name='col1'), ))
        if self.in_ is not None and 'in_' not in already_processed:
            already_processed.add('in_')
            outfile.write(' in=%s' % (self.gds_format_string(quote_attrib(self.in_).encode(ExternalEncoding), input_name='in'), ))
        if self.incol is not None and 'incol' not in already_processed:
            already_processed.add('incol')
            outfile.write(' incol=%s' % (self.gds_format_string(quote_attrib(self.incol).encode(ExternalEncoding), input_name='incol'), ))
        if self.where is not None and 'where' not in already_processed:
            already_processed.add('where')
            outfile.write(' where=%s' % (self.gds_format_string(quote_attrib(self.where).encode(ExternalEncoding), input_name='where'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='viewSubset', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constraint', node)
        if value is not None and 'constraint' not in already_processed:
            already_processed.add('constraint')
            self.constraint = value
        value = find_attr_value_('name1', node)
        if value is not None and 'name1' not in already_processed:
            already_processed.add('name1')
            self.name1 = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('col1', node)
        if value is not None and 'col1' not in already_processed:
            already_processed.add('col1')
            self.col1 = value
        value = find_attr_value_('in', node)
        if value is not None and 'in' not in already_processed:
            already_processed.add('in')
            self.in_ = value
        value = find_attr_value_('incol', node)
        if value is not None and 'incol' not in already_processed:
            already_processed.add('incol')
            self.incol = value
        value = find_attr_value_('where', node)
        if value is not None and 'where' not in already_processed:
            already_processed.add('where')
            self.where = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewSubset


class view(GeneratedsSuper):
    """A view inside another table or tables.Name of the view."""
    member_data_items_ = {
        'name': MemberSpec_('name', 'xs:string', 0),
        'subset': MemberSpec_('subset', 'viewSubset', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, name=None, subset=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.subset = subset
    def factory(*args_, **kwargs_):
        if view.subclass:
            return view.subclass(*args_, **kwargs_)
        else:
            return view(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subset(self): return self.subset
    def set_subset(self, subset): self.subset = subset
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.subset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='view', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='view')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='view', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='view'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='view', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subset is not None:
            self.subset.export(outfile, level, namespace_, name_='subset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subset':
            obj_ = viewSubset.factory()
            obj_.build(child_)
            self.subset = obj_
            obj_.original_tagname_ = 'subset'
# end class view


class views(GeneratedsSuper):
    """A single element inside the database; contains the list of views."""
    member_data_items_ = {
        'view': MemberSpec_('view', 'view', 1),
    }
    subclass = None
    superclass = None
    def __init__(self, view=None):
        self.original_tagname_ = None
        if view is None:
            self.view = []
        else:
            self.view = view
    def factory(*args_, **kwargs_):
        if views.subclass:
            return views.subclass(*args_, **kwargs_)
        else:
            return views(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_view(self): return self.view
    def set_view(self, view): self.view = view
    def add_view(self, value): self.view.append(value)
    def insert_view_at(self, index, value): self.view.insert(index, value)
    def replace_view_at(self, index, value): self.view[index] = value
    def hasContent_(self):
        if (
            self.view
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='views', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='views')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='views', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='views'):
        pass
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='views', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for view_ in self.view:
            view_.export(outfile, level, namespace_, name_='view', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'view':
            obj_ = view.factory()
            obj_.build(child_)
            self.view.append(obj_)
            obj_.original_tagname_ = 'view'
# end class views


class database(GeneratedsSuper):
    """Describes a database and (optionally) connection details.Name of the
    database.The actual kind of this database.The path on local
    computer where database is located (for SqLite, for
    example).Database user that will access the database.Password
    for database user.The host for databases on remote hosts.The
    port for databases on remote hosts."""
    member_data_items_ = {
        'username': MemberSpec_('username', 'xs:string', 0),
        'name': MemberSpec_('name', 'xs:string', 0),
        'driver': MemberSpec_('driver', 'xs:string', 0),
        'host': MemberSpec_('host', 'xs:string', 0),
        'path': MemberSpec_('path', 'xs:string', 0),
        'password': MemberSpec_('password', 'xs:string', 0),
        'port': MemberSpec_('port', 'xs:unsignedShort', 0),
        'tables': MemberSpec_('tables', 'tables', 0),
        'views': MemberSpec_('views', 'views', 0),
    }
    subclass = None
    superclass = None
    def __init__(self, username=None, name=None, driver=None, host=None, path=None, password=None, port=None, tables=None, views=None):
        self.original_tagname_ = None
        self.username = _cast(None, username)
        self.name = _cast(None, name)
        self.driver = _cast(None, driver)
        self.host = _cast(None, host)
        self.path = _cast(None, path)
        self.password = _cast(None, password)
        self.port = _cast(int, port)
        self.tables = tables
        self.views = views
    def factory(*args_, **kwargs_):
        if database.subclass:
            return database.subclass(*args_, **kwargs_)
        else:
            return database(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tables(self): return self.tables
    def set_tables(self, tables): self.tables = tables
    def get_views(self): return self.views
    def set_views(self, views): self.views = views
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_driver(self): return self.driver
    def set_driver(self, driver): self.driver = driver
    def get_host(self): return self.host
    def set_host(self, host): self.host = host
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def hasContent_(self):
        if (
            self.tables is not None or
            self.views is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='dbsm:', name_='database', namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='database')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='dbsm:', name_='database', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='dbsm:', name_='database'):
        if self.username is not None and 'username' not in already_processed:
            already_processed.add('username')
            outfile.write(' username=%s' % (self.gds_format_string(quote_attrib(self.username).encode(ExternalEncoding), input_name='username'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.driver is not None and 'driver' not in already_processed:
            already_processed.add('driver')
            outfile.write(' driver=%s' % (self.gds_format_string(quote_attrib(self.driver).encode(ExternalEncoding), input_name='driver'), ))
        if self.host is not None and 'host' not in already_processed:
            already_processed.add('host')
            outfile.write(' host=%s' % (self.gds_format_string(quote_attrib(self.host).encode(ExternalEncoding), input_name='host'), ))
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            outfile.write(' path=%s' % (self.gds_format_string(quote_attrib(self.path).encode(ExternalEncoding), input_name='path'), ))
        if self.password is not None and 'password' not in already_processed:
            already_processed.add('password')
            outfile.write(' password=%s' % (self.gds_format_string(quote_attrib(self.password).encode(ExternalEncoding), input_name='password'), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
    def exportChildren(self, outfile, level, namespace_='dbsm:', name_='database', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tables is not None:
            self.tables.export(outfile, level, namespace_, name_='tables', pretty_print=pretty_print)
        if self.views is not None:
            self.views.export(outfile, level, namespace_, name_='views', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('username', node)
        if value is not None and 'username' not in already_processed:
            already_processed.add('username')
            self.username = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('driver', node)
        if value is not None and 'driver' not in already_processed:
            already_processed.add('driver')
            self.driver = value
        value = find_attr_value_('host', node)
        if value is not None and 'host' not in already_processed:
            already_processed.add('host')
            self.host = value
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.add('path')
            self.path = value
        value = find_attr_value_('password', node)
        if value is not None and 'password' not in already_processed:
            already_processed.add('password')
            self.password = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            try:
                self.port = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tables':
            obj_ = tables.factory()
            obj_.build(child_)
            self.tables = obj_
            obj_.original_tagname_ = 'tables'
        elif nodeName_ == 'views':
            obj_ = views.factory()
            obj_.build(child_)
            self.views = obj_
            obj_.original_tagname_ = 'views'
# end class database


GDSClassesMapping = {
    'datetimeoffset': variablePrecisionTime,
    'subset': viewSubset,
    'text': parameterlessStringType,
    'image': parameterlessType,
    'numeric': decimal,
    'datetime': dateTimeType,
    'hierarchyid': parameterlessStringType,
    'numericScale0': decimalScale0,
    'nvarchar': nchar,
    'xml': parameterlessStringType,
    'smalldatetime': parameterlessStringType,
    'columns': columnList,
    'rowversion': parameterlessType,
    'varchar': char,
    'key': constraint,
    'date': dateType,
    'ntext': parameterlessStringType,
    'sql_variant': parameterlessStringType,
    'column': relationshipColumn,
    'datetime2': variablePrecisionTime,
    'time': timeType,
    'varbinary': binary,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'parameterlessType'
        rootClass = parameterlessType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'parameterlessType'
        rootClass = parameterlessType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'parameterlessType'
        rootClass = parameterlessType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:dbsm="http://pile-contributors.github.io/database/PileSchema.xsd"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'parameterlessType'
        rootClass = parameterlessType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from pile_schema_api import *\n\n')
        sys.stdout.write('import pile_schema_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "bigint",
    "binary",
    "bit",
    "char",
    "column",
    "columnList",
    "constraint",
    "constraintColumn",
    "database",
    "dateTimeType",
    "dateType",
    "decimal",
    "decimalScale0",
    "float_",
    "foreignKeyColumns",
    "identity",
    "index",
    "indexes",
    "integer",
    "money",
    "nchar",
    "parameterlessStringType",
    "parameterlessType",
    "primaryKey",
    "primaryKeyTable",
    "real",
    "relationship",
    "relationshipColumn",
    "relationships",
    "smallint",
    "smallmoney",
    "table",
    "tables",
    "timeType",
    "tinyint",
    "uniqueConstraints",
    "uniqueidentifier",
    "variablePrecisionTime",
    "view",
    "viewSubset",
    "views"
]
